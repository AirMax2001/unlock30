<template>
  <div class="game-container animated-red-background">
    <!-- Header con notificazioni -->
    <div class="game-header">
      <button class="back-button" @click="goHome">
        <i class="fas fa-arrow-left"></i> Torna alla Home
      </button>
      <h2 class="game-title">UNLOCK30</h2>
      
      <!-- Notifica di aggiornamento -->
      <div v-if="sceneUpdateNotification" class="update-notification">
        <i class="fas fa-sync-alt fa-spin"></i>
        Contenuto aggiornato!
      </div>
    </div>

    <!-- Loading -->
    <div v-if="loading" class="loading-container">
      <div class="spinner"></div>
      <p>Caricamento del gioco...</p>
    </div>

    <!-- Errore -->
    <div v-else-if="error" class="error-container">
      <i class="fas fa-exclamation-triangle"></i>
      <h3>Ops! Qualcosa è andato storto</h3>
      <p>{{ error }}</p>
      <button class="restart-button" @click="loadGameData">
        <i class="fas fa-redo"></i> Riprova
      </button>
    </div>

    <!-- Gioco -->
    <div 
      v-else-if="currentScene" 
      class="current-scene"
      :style="{ background: getSceneBackground(currentScene) }"
    >
      <!-- Contenuto scena -->
      <div class="scene-content">
        <h1 
          :class="['scene-title', getSceneTitleClass(currentScene)]"
          :style="{ color: currentScene.titleColor || '#ffffff' }"
        >
          {{ currentScene.title }}
        </h1>
        
        <!-- Media -->
        <div v-if="currentScene.image || currentScene.video" class="scene-media">
          <img 
            v-if="currentScene.image" 
            :src="getMediaUrl(currentScene.image)" 
            :alt="currentScene.title"
            class="scene-image"
          >
          <video 
            v-if="currentScene.video" 
            :src="getMediaUrl(currentScene.video)" 
            controls
            class="scene-video"
          >
            Il tuo browser non supporta i video.
          </video>
        </div>

        <!-- Descrizione -->
        <p class="scene-description">{{ currentScene.description }}</p>
      </div>

      <!-- Scelte -->
      <div v-if="currentScene.choices && currentScene.choices.length > 0 && !currentScene.isFinal" class="choices-container">
        <button 
          v-for="choice in currentScene.choices" 
          :key="choice.id"
          @click="makeChoice(choice)"
          class="choice-button"
          :disabled="processingChoice"
        >
          {{ choice.text }}
        </button>
      </div>

      <!-- Fine del gioco -->
      <div v-if="(!currentScene.choices || currentScene.choices.length === 0) || currentScene.isFinal" class="game-over">
        <h2>Fine dell'avventura!</h2>
        <p>Grazie per aver giocato a UNLOCK30</p>
        <button class="restart-button" @click="restartGame">
          <i class="fas fa-redo"></i> Ricomincia
        </button>
      </div>
    </div>
  </div>
</template>

<script>
import gameService from '../services/gameService.js'
import config from '../config.js'

export default {
  name: 'Game',
  data() {
    return {
      gameData: null,
      currentScene: null,
      currentSceneId: 1,
      loading: true,
      error: null,
      processingChoice: false,
      refreshInterval: null,
      lastUpdateTime: null,
      sceneUpdateNotification: false
    }
  },
  mounted() {
    this.loadGameData()
    this.startAutoRefresh()
  },
  beforeUnmount() {
    this.stopAutoRefresh()
  },
  methods: {
    startAutoRefresh() {
      // Controlla aggiornamenti ogni 15 secondi per il gioco (meno frequente dell'admin)
      this.refreshInterval = setInterval(() => {
        this.checkForUpdates()
      }, 15000)
    },

    stopAutoRefresh() {
      if (this.refreshInterval) {
        clearInterval(this.refreshInterval)
      }
    },

    async checkForUpdates() {
      try {
        // Controlla se ci sono aggiornamenti senza interferire con l'esperienza di gioco
        const freshData = await gameService.forceRefresh()
        
        if (freshData && this.gameData) {
          const currentSceneCount = this.gameData.scenes.length
          const newSceneCount = freshData.scenes.length
          
          // Se sono cambiate le scene, aggiorna discretamente
          if (newSceneCount !== currentSceneCount || 
              freshData.stats?.lastModified !== this.gameData.stats?.lastModified) {
            
            console.log('[GAME AUTO-REFRESH] Aggiornamenti rilevati, refresh in corso...')
            
            // Salva la scena corrente prima dell'aggiornamento
            const currentSceneId = this.currentSceneId
            
            // Aggiorna i dati
            this.gameData = freshData
            this.lastUpdateTime = new Date()
            
            // Ricarica la scena corrente con i nuovi dati (se esiste ancora)
            if (currentSceneId && freshData.scenes.find(s => s.id === currentSceneId)) {
              this.loadScene(currentSceneId)
              
              // Mostra notifica discreta di aggiornamento
              this.showUpdateNotification()
            }
          }
        }
      } catch (error) {
        console.warn('[GAME AUTO-REFRESH] Errore nel controllo aggiornamenti:', error)
        // Non mostrare errori all'utente per non disturbare il gioco
      }
    },

    showUpdateNotification() {
      // Mostra notifica discreta che scompare automaticamente
      this.sceneUpdateNotification = true
      setTimeout(() => {
        this.sceneUpdateNotification = false
      }, 3000)
    },

    async loadGameData(forceRefresh = false) {
      this.loading = true
      this.error = null
      
      try {
        const data = await gameService.loadGameData()
        this.gameData = data
        this.loadScene(1) // Carica la prima scena
        
        console.log('✅ Dati gioco caricati:', data.scenes?.length || 0, 'scene')
      } catch (error) {
        this.error = 'Impossibile caricare i dati del gioco.'
        console.error('Errore nel caricamento:', error)
      } finally {
        this.loading = false
      }
    },
    
    loadScene(sceneId) {
      if (!this.gameData || !this.gameData.scenes) {
        this.error = 'Dati del gioco non validi'
        return
      }
      
      const scene = this.gameData.scenes.find(s => s.id === sceneId)
      if (!scene) {
        this.error = `Scena con ID ${sceneId} non trovata`
        return
      }
      
      this.currentScene = scene
      this.currentSceneId = sceneId
      console.log('Scena caricata:', scene)
    },
    
    async makeChoice(choice) {
      if (this.processingChoice) return
      
      this.processingChoice = true
      
      try {
        // Simula un piccolo delay per l'effetto
        await new Promise(resolve => setTimeout(resolve, 300))
        
        if (choice.nextSceneId) {
          this.loadScene(choice.nextSceneId)
        } else {
          console.warn('Scelta senza nextSceneId:', choice)
        }
      } catch (error) {
        console.error('Errore nella scelta:', error)
        this.error = 'Errore nel processare la scelta'
      } finally {
        this.processingChoice = false
      }
    },
    
    restartGame() {
      this.currentSceneId = 1
      this.currentScene = null
      this.error = null
      this.processingChoice = false
      this.loadGameData()
    },
    
    goHome() {
      this.$router.push('/')
    },

    getMediaUrl(path) {
      if (!path) return ''
      if (path.startsWith('http')) return path
      
      // Se è un percorso relativo, aggiunge il dominio del backend
      const baseUrl = config.API_BASE_URL || window.location.origin
      return path.startsWith('/') ? `${baseUrl}${path}` : `${baseUrl}/${path}`
    },

    // METODI PER LA GESTIONE DEGLI STILI
    getSceneBackground(scene) {
      if (!scene.backgroundTheme) return ''
      
      const themes = {
        fire: 'linear-gradient(45deg, #ff6b35, #ff4757)',
        water: 'linear-gradient(45deg, #3742fa, #2f3542)',
        nature: 'linear-gradient(45deg, #2ed573, #1e90ff)',
        space: 'linear-gradient(45deg, #5f27cd, #341f97)',
        horror: 'linear-gradient(45deg, #8b0000, #2c0000)',
        gold: 'linear-gradient(45deg, #f1c40f, #f39c12)'
      }
      
      return themes[scene.backgroundTheme] || ''
    },

    getSceneTitleClass(scene) {
      const classes = ['scene-title']
      
      if (scene.titleStyle) {
        classes.push(`style-${scene.titleStyle}`)
      }
      
      if (scene.effects?.glow) {
        classes.push('glow-effect')
      }
      
      return classes
    }
  }
}
</script>
/ /   a u t o   r e c o m p i l e 
 
 